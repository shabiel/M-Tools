ZZUTXTD4 ;OAKLAND-OIFO/JLI-UNIT TESTS FOR XTDEBUG - CONTINUATION ;2/14/08  11:48
 ;;7.3;TOOLKIT;**???**;Apr 25, 1995
 I $T(EN^XTMUNIT)'="" D UT ; RUNS UNIT TESTS WITH LOGGING TURNED ON
 Q
 ;
UT ;
 K ^TMP("XTDEBUG2",$J),^TMP("XTDEBUG1",$J),^TMP("XTDEBUG3",$J)
 K ^TMP("XTDEBUG",$J),^TMP("XTDEBUG-S",$J)
 D INITEASY^XTMLOG("G,DEBUG-DATAX","DEBUG")
 D EN^XTMUNIT("ZZUTXTD4") ; 1")
 D ENDLOG^XTMLOG
 Q
 ;
TAGPARTS ;
 N TAGVAL,RESULTS
 S TAGVAL="TESTENT+4^ZZUTXTD1(VAR1,VAR2)"
 D TAGPARTS^XTDEBUG(.RESULTS,TAGVAL)
 D CHKEQ^XTMUNIT(RESULTS("LINE"),"TESTENT+4","LINE value incorrect")
 D CHKEQ^XTMUNIT(RESULTS("ROUTINE"),"ZZUTXTD1","ROUTINE value incorrect")
 D CHKEQ^XTMUNIT(RESULTS("ARGS"),"VAR1,VAR2","ARGS value incorrect")
 Q
 ;
COMMANDS ;
 N ZZUTGLOB,ZZUTLINE,X,Y,Z,RES,ZZUTVALS
 N XTDEBQUI,ZZLEVEL
 S ZZUTGLOB=$$GETGLOBS^XTDEBUG() K @ZZUTGLOB
 S ZZUTGLOB=$$GETGLOB^XTDEBUG() K @ZZUTGLOB
 S ZZUTLINE="S X=3,Y=4,Z=X+Y Q:X=3  S Y=1"
 S ZZUTLINE=$$GETCMND^XTDEBUG(.ZZUTVALS,ZZUTLINE)
 S @ZZUTGLOB@("LASTLVL")=1
 S @ZZUTGLOB@("EXITTYPE")="STEP"
 S @ZZUTGLOB@("LVL",1,"CMND")=ZZUTLINE
 K @ZZUTGLOB@("LVL",1,"XTDEBARG")
 M @ZZUTGLOB@("LVL",1,"XTDEBARG")=ZZUTVALS
 D STRTCMND^XTDEBUG ; step onto line and execute first command
 D INFO^XTMLOG("BACK FROM STRTCMND")
 D NEXT^XTDEBUG(.RES,"STEP")
 ;
 D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 1")
 D CHKEQ^XTMUNIT($G(Y),"","Bad value of Y 1")
 D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",1,"ENTRY")),"COMMANDS^XTDEBUG","Didnt set up for re-entry")
 ;
 D NEXT^XTDEBUG(.RES,"STEP")
 D INFO^XTMLOG("BACK FROM NEXT 1")
 D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 2")
 D CHKEQ^XTMUNIT($G(Y),4,"Bad value of Y 2")
 D CHKEQ^XTMUNIT($G(Z),"","Bad value of Z 2")
 ;
 D NEXT^XTDEBUG(.RES,"STEP")
 D INFO^XTMLOG("BACK FROM NEXT 2")
 D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 3")
 D CHKEQ^XTMUNIT($G(Y),4,"Bad value of Y 3")
 D CHKEQ^XTMUNIT($G(Z),7,"Bad value of Z 3")
 ;
 D NEXT^XTDEBUG(.RES,"STEP")
 D INFO^XTMLOG("BACK FROM NEXT 3")
 D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",1,"ENTRY")),"","Didn't reset re-entry value")
 ;
 S ZZUTLINE=$$GETCMND^XTDEBUG(.ZZUTVALS,ZZUTLINE)
 S ZZLEVEL=@ZZUTGLOB@("LASTLVL")
 S @ZZUTGLOB@("LVL",ZZLEVEL,"CMND")=ZZUTLINE
 K @ZZUTGLOB@("LVL",ZZLEVEL,"XTDEBARG")
 M @ZZUTGLOB@("LVL",ZZLEVEL,"XTDEBARG")=ZZUTVALS
 ;
 D STRTCMND^XTDEBUG ;(.ZZUTVALS,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"STEP")
 D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",ZZLEVEL,"CMND")),"S Y=1","Didn't clear rest of line")
 Q
 ;
DOLINE ;
 N ZZUTLINE,X,Y,XTDEBLOC,XTDEBTYP
 S ZZUTLINE="S X=4,Y=3 D TESTENT^ZZUTXTD1(X,Y) F I=1:1:5 Q:I=3  S X=X+I ; COMMENT"
 S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC
 S XTDEBTYP="RUN"
 S @XTDEBLOC@("LASTLVL")=0
 S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
 S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
 Q
 D DOLINE^XTDEBUG
 Q
 D CHKEQ^XTMUNIT($G(X),7,"Return value was not expected value")
 ; TODO - add tests for DLINEB
 Q
 ;
DOLRDOLR ;
 N XTDEBLOC,XTNOARG,ZZUTLINE,XTDEBEN1,RESULTS,XVAL,RES
 S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC S XTNOARG=$$RESULTS^XTDEBUG()
 S ZZUTLINE="S XVAL=$$GETGLOB^XTDEBUG()"
 ;S @XTDEBLOC@("LASTLVL")=0
 ;S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
 ;S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
 ;S @XTDEBLOC@("EXITTYPE")="RUN",XTDEBEN1=1
 ;D DOLINE^XTDEBUG
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 ; D NEXT^XTDEBUG(.RES,"STEP") ; NEEDED IF STEP IS USED AS EXITTYPE
 ; D NEXT^XTDEBUG(.RES,"STEP") ; NEEDED IF STEP IS USED AS EXITTYPE
 D CHKEQ^XTMUNIT($G(XVAL),"^TMP(""XTDEBUG"","_$J_")","1 Incorrect value")
 Q
 ;
SETDOLR ;
 N XTDEBLOC,XTNOARG,ZZUTLINE,XTDEBEN1,XVAL,RES
 S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC S XTNOARG=$$RESULTS^XTDEBUG()
 S ZZUTLINE="S XVAL=$$FACTORIL^ZZUTXTD1(3)"
 ;S @XTDEBLOC@("LASTLVL")=0
 ;S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
 ;S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
 ;S @XTDEBLOC@("EXITTYPE")="",XTDEBEN1=1
 ;D DOLINE^XTDEBUG
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(XVAL),6,"Incorrect value")
 ;
 S ZZUTLINE="S XVAL=$$NOW^ZZUTXTD4()"
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ(XVAL\1,$$NOW^ZZUTXTD4()\1,"Didn't return correct date value")
 ;
 S ZZUTLINE="S XVAL=XVAL\1"
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ(XVAL,$$NOW^ZZUTXTD4()\1,"Didn't return correct value from integer div")
 ;
 S ZZUTLINE="S XVAL=$$NOW^ZZUTXTD4()\1"
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ(XVAL,$$NOW^ZZUTXTD4()\1,"Didn't return value from function and integer div")
 ;
 S ZZUTLINE="S XVAL=$$TSTDOLRS($$NOW^ZZUTXTD4()\1,1)"
 D START^XTDEBUG(.RES,ZZUTLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ(XVAL,($$NOW^ZZUTXTD4()\1)+1,"Incorrect value from $$TSTDOLRS")
 Q
 ;
NOW() ;
 Q 3070223.124
 ;
DONOARG ; process argumentless DO command
 ;N XTJLI ;S XTJLI=1
 N XTDEBLOC,XTNOARG,ZZLINNUM,RESULTS,ZZLVL
 S XTNOARG=$$RESULTS^XTDEBUG() K @XTNOARG
 S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC
 D START^XTDEBUG(.RESULTS,"D NOARG^ZZUTXTD1") ; ;
 S ZZLINNUM=$$LINENUM^XTDEBUG("ZZUTXTD1","NOARG")
 D NEXT^XTDEBUG(.RESULTS,"STEP")
 S ZZLVL=+@XTDEBLOC@("LASTLVL")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),";","CMND value not expected")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM,"Line Number not correct")
 ; move into unargumented level, test functionality of SETNOARG
 K ^TMP("XTDEBUG2",$J)
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; D  S
 ; SETNOARG should increment the level
 S ZZLVL=+@XTDEBLOC@("LASTLVL")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"D","CMND value not expected")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+1,"Line Number not correct")
 ;
 ; execute the line
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; . S
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LASTLVL")),2,"Wrong Level")
 S ZZLVL=+@XTDEBLOC@("LASTLVL")
 ; and SETNOARG should set value of "NOARG" node to depth of DO's with NOARGs
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"S","CMND value not expected")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+2,"Line Number not correct")
 ;
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; D S
 S ZZLVL=+@XTDEBLOC@("LASTLVL")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"S","CMND value not expected")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+1,"Line Number not correct")
 D CHKEQ^XTMUNIT($G(Y),1,"Y value not correct")
 ;
 D NEXT^XTDEBUG(.RESULTS,"STEP")
 S ZZLVL=+@XTDEBLOC@("LASTLVL")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"Q","CMND value not expected")
 D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+3,"Line Number not correct")
 D CHKEQ^XTMUNIT($G(Y),1,"Final Y value not correct")
 D CHKEQ^XTMUNIT($G(X),3,"Final X value not correct")
 ; needs to set proper starting line number
 D NEXT^XTDEBUG(.RESULTS,"STEP")
 Q
 ;
DONOARG1 ;
 N X,Y,Z,N,RESULTS,XTDEBLOC
 S X=0,Y=0,Z=0,N=0
 S XTDEBLOC=$$GETGLOB^XTDEBUG()
 D START^XTDEBUG(.RESULTS,"D NOARG1^ZZUTXTD1")
 D NEXT^XTDEBUG(.RESULTS,"RUN")
 ;
 D CHKEQ^XTMUNIT($G(X),1,"Final X value not correct")
 D CHKEQ^XTMUNIT($G(Y),7,"Final X value not correct")
 D CHKEQ^XTMUNIT($G(Z),5,"Final X value not correct")
 D CHKEQ^XTMUNIT($G(N),4,"Final X value not correct")
 Q
 ;
GETPERIO ;
 N ZZLINE,NPERIODS
 S ZZLINE="THIS LINE"
 S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
 D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned for no periods")
 D CHKEQ^XTMUNIT(NPERIODS,0,"Incorrect number of periods for none there")
 ;
 S ZZLINE=" . . . THIS LINE"
 S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
 D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned for periods with spaces")
 D CHKEQ^XTMUNIT(NPERIODS,3,"Incorrect number of periods with spaces")
 ;
 S ZZLINE="..THIS LINE"
 S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
 D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned with no spaces")
 D CHKEQ^XTMUNIT(NPERIODS,2,"Incorrect number of periods with no spaces")
 Q
 ;
DOLRSX ;
 N ZZLINE,X,Y,RES,XVALUE
 S ZZLINE="S X=$S(Y=1:3,1:0)"
 S Y=1
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKTF^XTMUNIT($G(X)=3,"Incorrect value from $S")
 ;
 S Y=4
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(X),0,"Incorrect value from $S")
 ;
DOLRS ;
 ;N XTJLI S XTJLI=1
 N ZZLINE,YVALUE,RES,XVALUE,X
 S ZZLINE="S X=$$TSTDOLRS^ZZUTXTD4($S(YVALUE=1:3,1:0),3)"
 S YVALUE=1
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(X),6,"NOT CORRECT")
 ;
 S YVALUE=0
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(X),3,"NOT CORRECT")
 ;
 S ZZLINE="S XVALUE=$$TSTDOLRS^ZZUTXTD4(YVALUE,XVALUE)"
 S YVALUE=1,XVALUE=4,X=3,Y=1
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(XVALUE),5,"Incorrect value with $S as arg to function")
 ;
 S YVALUE=0,XVALUE=4
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKEQ^XTMUNIT($G(XVALUE),4,"Incorrect value with $S as arg to function")
 Q
 ;
TSTDOLRS(VALUE,VALUE1) ;
 Q VALUE+VALUE1
 ;
PASBYREF ;
 N ZZLINE,X,RES
 S ZZLINE="S X=0 D TSTBYREF^ZZUTXTD4(X)"
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKTF^XTMUNIT(X=0,"Acts like pass by reference when it isn't")
 ;
 S ZZLINE="S X=0 D TSTBYREF^ZZUTXTD4(.X)"
 D START^XTDEBUG(.RES,ZZLINE)
 D NEXT^XTDEBUG(.RES,"RUN")
 D CHKTF^XTMUNIT(X=4,"Pass by ref didn't affect value")
 D CHKTF^XTMUNIT($D(X)>1,"Pass by ref didn't return subscripted values")
 D CHKTF^XTMUNIT($G(X(3))=6,"Pass by ref didn't return correct subscript value")
 Q
 ;
TSTBYREF(VALUE) ;
 ; Q:VALUE=+VALUE
 ; Q:$E(VALUE)'?1A
 S VALUE=4
 S VALUE(3)=6
 Q
 ;
CHKARGS ;
 N ZZINPUT,ZZLINE,ZZXX
 S ZZLINE="X=Y*$$NOW^ZZUTXTD4()+$$TSTDOLRS($S(Y=3:1,1:0))-$$NOW^ZZUTXTD3+1"
 S ZZINPUT=ZZLINE
 S ZZXX=$$CHKARGS^XTDEBUG(.ZZINPUT)
 D CHKEQ(ZZXX,"S XTDEBV(4)=$$NOW^ZZUTXTD3 S XTDEBV(3)=$S(Y=3:1,1:0) S XTDEBV(2)=$$TSTDOLRS(XTDEBV(3)) S XTDEBV(1)=$$NOW^ZZUTXTD4()","BAD PRE-PROCESSING VALUES")
 D CHKEQ(ZZINPUT,"X=Y*XTDEBV(1)+XTDEBV(2)-XTDEBV(4)+1")
 Q
PREPROS ;
 N ZZLINE,XTDEBLOC,Y,X,XTDEBV
 S ZZLINE="S XTDEBV(4)=$$NOW,XTDEBV(3)=$S(Y=3:1,1:0),XTDEBV(2)=$$TSTDOLRS(XTDEBV(3),4),XTDEBV(1)=$$NOW^ZZUTXTD4()"
 S Y=3
 S XTDEBLOC=$$GETGLOB^XTDEBUG()
 S @XTDEBLOC@("LASTLVL")=0
 S @XTDEBLOC@("LVL",0,"ARGS","CURR")=3
 S @XTDEBLOC@("LVL",0,"CMND")="Q"
 S @XTDEBLOC@("LVL",0,"PRE-PROCESS")=ZZLINE
 S @XTDEBLOC@("LVL",0,"ROUTINE")="ZZUTXTD4"
 S @XTDEBLOC@("LVL",0,"XTDEBARG","ARGS",3)="X=Y*XTDEBV(1)+XTDEBV(2)-XTDEBV(4)+1"
 S @XTDEBLOC@("LVL",0,"XTDEBARG","CMND")="S"
 D PREPROCS^XTDEBUG
 D CHKTF^XTMUNIT(X=6140452.248,"Bad value returned from PREPROCS")
 Q
 ;
CHKEQ(VAR1,VAR2,ERRMSG) ;
 D CHKEQ^XTMUNIT(VAR1,VAR2,$G(ERRMSG))
 Q
 ;
CHKTF(VAR,ERRMSG) ;
 D CHKTF^XTMUNIT(VAR,$G(ERRMSG))
 Q
 ;
XTROU ;
 ;;ZZUTXTD1;
XTENT ;
 ;;DOLRSX;simple $SELECT
 ;;DOLRS;handle $SELECT
 ;;PREPROS;PRE-PROCESSING OF $$ AND $S
 ;;CHKARGS;check for arguments needing pre-processing
 ;;PASBYREF;handle arguments passed by reference
 ;;SETDOLR;various tests of functions
 ;;DONOARG1;multiple argless DO commands
 ;;GETPERIO;returns number of periods at start of line
 ;;DONOARG;handle unargumented DO commands
 ;;DOLINE;handle a line of code
 ;;TAGPARTS;get individual parts of the TAG entry
 ;;COMMANDS;handle various types of commands
 ;;DOLRDOLR;handle intrinsic functions
