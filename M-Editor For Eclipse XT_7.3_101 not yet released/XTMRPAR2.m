XTMRPAR2 ;FO-OAK/JLI - list tags, find variables that aren't arguments or newed - continued ;10/28/10  16:28
 ;;7.3;TOOLKIT;**101**;Apr 25, 1995
 ;;Per VHA Directive 2004-038, this routine should not be modified
 ; 101021 fixed a problem in ARGLIST where parentheses and quotes were not completed to the closing member
 Q
 ;
GETPAREN(LINE,VALUE,TERM) ;
 N ARGCNT,ARGVAL,PARENCNT,TOKEN
 S PARENCNT=1,ARGCNT=0,ARGVAL=TERM,TERM=""
 F  S ARGVAL=ARGVAL_TERM Q:(PARENCNT=0)&((TERM=",")!(TERM=")"))  Q:LINE=""  D
 . S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGVAL=ARGVAL_TOKEN S:TERM="(" PARENCNT=PARENCNT+1 S:TERM=")" PARENCNT=PARENCNT-1
 . Q
 S VALUE=ARGVAL
 Q LINE
 ;
GETARGS(LINE,LOCSTOR,SUBSCRPT) ;
 N TOKEN,TERM,ARGCNT S TERM="1",ARGCNT=0
 S SUBSCRPT=$G(SUBSCRPT) S:SUBSCRPT="" SUBSCRPT="ARG"
 F  Q:(TERM=" ")!(TERM="")  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) D
 . S ARGCNT=ARGCNT+1,LINE=$$ARGLIST(LINE,.TOKEN,.TERM)
 . S @LOCSTOR@(SUBSCRPT,ARGCNT)=TOKEN I TERM=":" S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S @LOCSTOR@(SUBSCRPT,ARGCNT,"COND")=TOKEN I TERM
 . Q
 Q LINE
 ;
ARGLIST(LINE,ARGVALUE,TERM) ;
 N TOKEN
 S ARGVALUE=$G(ARGVALUE)
 I (TERM=" ")!(TERM=",")!(TERM="") Q LINE
 ;
 I TERM="(" D
 . S LINE=$$GETPAREN(LINE,.TOKEN,.TERM)
 . S ARGVALUE=ARGVALUE_TOKEN
 . ; 101021 commented out following, replaced with new code to handle text following ( and " characters correctly
 . ;F  Q:LINE=""  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGVALUE=ARGVALUE_TOKEN Q:(TERM=",")!(TERM=" ")!(TERM="")!(TERM="$")!(TERM=":")  S ARGVALUE=ARGVALUE_TERM
 . F  Q:LINE=""  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM)  S ARGVALUE=ARGVALUE_TOKEN D:"("""[TERM  Q:(TERM=",")!(TERM=" ")!(TERM="")!(TERM="$")!(TERM=":")  S ARGVALUE=ARGVALUE_TERM
 . . N THISTERM
 . . S THISTERM=TERM
 . . S ARGVALUE=ARGVALUE_TERM
 . . I THISTERM="""" S LINE=$$GETQUOTE(LINE,.TOKEN,.TERM)
 . . I THISTERM="(" S TERM="",LINE=$$GETPAREN(LINE,.TOKEN,.TERM) I TERM=")" S TOKEN=$E(TOKEN,1,$L(TOKEN)-1)
 . . S ARGVALUE=ARGVALUE_TOKEN
 . . Q
 . ; end of 101021 insertion
 . Q
 I TERM="$" S ARGVALUE=ARGVALUE_TERM D
 . F  Q:LINE=""  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGVALUE=ARGVALUE_TOKEN Q:(TERM=",")!(TERM=" ")!(TERM="")  S ARGVALUE=ARGVALUE_TERM
 . Q
 Q LINE
 ;
GETCMD(LINE,LINENUM,ARGNUM,LOCSTOR) ;
 N CMD,TOKEN,TERM,CONDNUM,I,LIST1,LIST2
 F  Q:$E(LINE,1)'=" "  S LINE=$E(LINE,2,$L(LINE))
 I $E(LINE,1)=";" S ARGNUM=ARGNUM+1,@LOCSTOR@(LINENUM,ARGNUM,"COMMENT")=LINE,LINE="" Q LINE
 S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM),CMD=""
 S LIST1="A^B^C^D^E^F^G^H^I^J^K^L^M^N^O^P^Q^R^S^T^U^V^W^X^Y^Z"
 S LIST2="A^BREAK^C^DO^ELSE^FOR^GO^HALT^IF^JOB^KILL^LOCK^MERGE^NEW^OPEN^P^QUIT^READ^SET^T^USE^V^WRITE^X^Y^Z"
 F I=1:1:$L(LIST1,U) I $$UP(TOKEN)=$P(LIST1,U,I) S CMD=$P(LIST2,U,I)
 I CMD="" I U_LIST2_U[U_$$UP(TOKEN)_U S CMD=$$UP(TOKEN)
 I CMD="" S CMD="UNKNOWN - "_TOKEN
 S ARGNUM=ARGNUM+1
 S @LOCSTOR@(LINENUM,ARGNUM,"CMD")=CMD
 I TERM=":" S CONDNUM=1 S LINE=$$GETARGS(LINE,$NA(@LOCSTOR@(LINENUM,ARGNUM,"CMD")),"COND") S TERM="" I LINE'="" S TERM=" "
 I TERM=" " S LINE=$$GETARGS(LINE,$NA(@LOCSTOR@(LINENUM,ARGNUM,"CMD")))
 I TERM=";" S @LOCSTOR@(LINENUM,ARGNUM,"COMMENT")=TERM_LINE S LINE=""
 Q LINE
 ;
GETTAGS(LOC,TAGLOC) ;
 N I,NTAGS,J,X S NTAGS=0
 F I=0:0 S I=$O(@LOC@(I)) Q:I'>0  I $D(@LOC@(I,0,"TAG")) D
 . I NTAGS>0,$G(@TAGLOC@(NTAGS,"Q"))>0,I'>@TAGLOC@(NTAGS,"Q") Q  ; skip non-entry tags
 . S NTAGS=NTAGS+1,@TAGLOC@(NTAGS)=I,@TAGLOC@(NTAGS,"NAME")=@LOC@(I,0,"TAG")
 . F J=I:0 S J=$O(@LOC@(J)) Q:J'>0  S X=$G(@LOC@(J,1,"CMD")) I ((X="GO")!(X="QUIT")!(X="G")!(X="Q")),'$D(@LOC@(J,1,"CMD","COND")),'$D(@LOC@(J,2,"CMD")),'$D(@LOC@(J,0,"INDENT")) S @TAGLOC@(NTAGS,"Q")=J Q
 Q
 ;
LOAD(ROU,GLOB) ;
 N X,XCNP,DIF
 K @GLOB
 S X=ROU,XCNP=0,DIF=$E(GLOB,1,$L(GLOB)-1)_"," X ^%ZOSF("LOAD")
 F X=0:0 S X=$O(@GLOB@(X)) Q:X'>0  S DIF=X
 S @GLOB@(DIF+1,0)=" Q" ; make sure a quit is at the bottom
 Q
 ;
SETTAG(LINE,LINENUM,STORLOC) ;
 ; added corrections for infinite loop if parens are unmatched on TAG 090720
 N TERM,TOKEN
 S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM)
 S @STORLOC@(LINENUM,0,"TAG")=TOKEN I TERM=" " Q LINE
 I TERM'="(" D MARKERR("Bad char following TAG at line "_LINENUM) Q LINE
 I LINE="" D MARKERR("No args following open paren at line "_LINENUM) Q LINE ; 090720
 N ARGCNT,ARGVAL,PARENCNT S PARENCNT=0,ARGCNT=0,ARGVAL=""
 ;F  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGCNT=ARGCNT+1 D  S @STORLOC@(LINENUM,0,"TAG","ARG",ARGCNT)=ARGVAL,ARGVAL="" Q:TERM=")" ; JLI replaced by next line 090720
 F  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGCNT=ARGCNT+1 D  Q:TERM=""  S @STORLOC@(LINENUM,0,"TAG","ARG",ARGCNT)=ARGVAL,ARGVAL="" Q:TERM=")"  ; JLI 090720
 . I TERM="" D MARKERR("Unmatched Paren following TAG at line "_LINENUM) S ARGCNT=ARGCNT-1 Q  ; JLI 090720
 . S ARGVAL=ARGVAL_TOKEN
 . F  Q:(PARENCNT=0)&((TERM=",")!(TERM=")"))  S:TERM="(" PARENCNT=PARENCNT+1 S:TERM=")" PARENCNT=PARENCNT-1 S ARGVAL=ARGVAL_TERM Q:LINE=""  S LINE=$$NEXTTOKN(LINE,.TOKEN,.TERM) S ARGVAL=ARGVAL_TOKEN
 Q LINE
 ;
MARKERR(TEXT) ;
 W !,TEXT
 Q
 ;
NEXTTOKN(LINE,TOKEN,TERM,TERMCHRS) ;
 ; modified 4/10/08 to add TERMCHRS as an OPTIONAL input variable,
 ;   if present it specifies the list of possible terminating characters
 N DONE,CHAR,PARENS,READY
 S:$G(TERMCHRS)="" TERMCHRS=" ,:()"
 S TOKEN="",TERM="",PARENS=0
 F  Q:LINE=""  S READY=1,CHAR=$E(LINE,1),LINE=$E(LINE,2,999) D  I PARENS=0,READY,TERMCHRS[CHAR S TERM=CHAR Q
 . I '((CHAR=")")&(PARENS>0)) Q:TERMCHRS[CHAR
 . ;I CHAR="(" S PARENS=PARENS+1
 . ;I CHAR=")" S PARENS=PARENS-1,READY=0
 . S TOKEN=TOKEN_CHAR
 . I CHAR="""" S LINE=$$GETQUOTE(LINE,.TOKEN,.CHAR) I TERMCHRS'[CHAR S TOKEN=TOKEN_CHAR
 . Q
 Q LINE
 ;
GETQUOTE(LINE,TOKEN,TERM) ;
 N CHAR,DONE
 F  Q:LINE=""  S CHAR=$E(LINE,1),LINE=$E(LINE,2,999),TOKEN=TOKEN_CHAR I CHAR="""" D  I DONE Q
 . ; following 2 lines retracted after problems
 . ;I $E(LINE,1)="""" S TOKEN=TOKEN_CHAR,LINE=$E(LINE,2,$L(LINE)) Q
 . ;S TERM=$E(LINE,1),LINE=$E(2,$L(LINE)),DONE=1
 . S TERM=$E(LINE,1),LINE=$E(LINE,2,999),DONE=1
 . I TERM="""" S TOKEN=TOKEN_TERM,DONE=0
 . Q
 Q LINE
 ;
 ;
UP(X) Q $$UP^XLFSTR(X)
