ZZUTXTD3 ;OAKLAND-OIFO/JLI-UNIT TESTS FOR XTDEBUG - CONTINUATION ;05/10/08  16:24
 ;;7.3;TOOLKIT;**???**;Apr 25, 1995
 K ^TMP("XTDEBUG2"),^TMP("XTDEBUG1"),^TMP("XTDEBUG3")
 K ^TMP("XTDEBUG")
 D EN^XTMUNIT("ZZUTXTD3")
 Q
 ;
TESTNEXT ;
 N GLOBLOC,ROU,LIN,VAR1,VAR2,RESULTS,X,IVAL,LINNUM
 S GLOBLOC=$$GETGLOB^XTDEBUG() K @GLOBLOC
 S ROU="ZZUTXTD1",LIN="TESTENT+2"
 S @GLOBLOC@("LASTLVL")=1,@GLOBLOC@("LVL",1,"ROUTINE")=ROU,VAR1=1,VAR2=2
 S LINNUM=$$LINENUM^XTDEBUG(ROU,LIN),@GLOBLOC@("LVL",1,"LINE")=LINNUM
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; step onto line
 D CHKEQ^XTMUNIT($G(@GLOBLOC@("LVL",1,"LINE")),LINNUM+1,"Wrong current line number")
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; execute code
 F IVAL=1:1 S IVAL=$O(@RESULTS@("VALUES",IVAL)) Q:IVAL'>0  I @RESULTS@("VALUES",IVAL)="X" Q
 D CHKTF^XTMUNIT(IVAL>0,"X not found in results")
 I IVAL>0 D CHKEQ^XTMUNIT(@RESULTS@("VALUES",IVAL+1),1,"Value of X not expected")
 ; made it so line is not incremented automatically
 Q
 ;
GETCMND ;
 N CMND,REST,VALUES
 S CMND="S CMND=X S X=4"
 S REST=$$GETCMND^XTDEBUG(.VALUES,CMND)
 D CHKEQ^XTMUNIT($G(VALUES("CMND")),"S","Bad command from GETCMND")
 D CHKEQ^XTMUNIT(REST,"S X=4","Bad rest of line from GETCMND")
 S CMND="S:Y'=0 X=4+1,Y=13 S Z=X+Y"
 S REST=$$GETCMND^XTDEBUG(.VALUES,CMND)
 D CHKEQ^XTMUNIT($G(VALUES("CMND")),"S","Bad command from GETCMND")
 D CHKEQ^XTMUNIT($G(VALUES("PRECOND")),"Y'=0","Bad value for PRECOND")
 D CHKEQ^XTMUNIT($G(VALUES("ARGS",1)),"X=4+1","Bad ARG value returned")
 D CHKEQ^XTMUNIT($G(VALUES("ARGS",2)),"","Bad second ARG value returned")
 D CHKEQ^XTMUNIT(REST,"S:Y'=0 Y=13 S Z=X+Y","Bad rest of line from GETCMND")
 S CMND="R X:5 S XX(Y)=X"
 S REST=$$GETCMND^XTDEBUG(.VALUES,CMND)
 D CHKEQ^XTMUNIT($G(VALUES("CMND")),"R","Bad command from GETCMND")
 D CHKEQ^XTMUNIT($G(VALUES("PRECOND")),"","Precond value returned")
 D CHKEQ^XTMUNIT($G(VALUES("ARGS",1)),"X","Bad arg value returned")
 D CHKEQ^XTMUNIT($G(VALUES("ARGS",1,"POSTCOND")),"5","Bad Postcond value returned")
 D CHKEQ^XTMUNIT(REST,"S XX(Y)=X","Bad rest of line from GETCMND")
 Q
 ;
GETSTR ;
 N STR,REST
 S REST=$$GETSTR^XTDEBUG(.STR,"S X=4"," ")
 D CHKEQ^XTMUNIT($G(STR),"S","Bad return STR from GETSTR")
 D CHKEQ^XTMUNIT($G(STR("TERM"))," ","Bad terminator from GETSTR")
 D CHKEQ^XTMUNIT(REST,"X=4","Bad return value from GETSTR")
 S REST=$$GETSTR^XTDEBUG(.STR,"XX(""A B"",""C"",4),YY(4)"," ,")
 D CHKEQ^XTMUNIT($G(STR),"XX(""A B"",""C"",4)","Bad return STR from GETSTR")
 D CHKEQ^XTMUNIT($G(STR("TERM")),",","Bad terminator from GETSTR")
 D CHKEQ^XTMUNIT(REST,"YY(4)","Bad function value from GETSTR")
 Q
 ;
SETUPFOR ;
 ; ZEXCEPT: CMND,REST,RESULTS,XTDEBLOC - newed in calling code
 S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC
 S @XTDEBLOC@("LASTLVL")=1
 S @XTDEBLOC@("LVL",1,"ROUTINE")="@",^("LINE")=""
 S CMND="F IVAL=1:1:5 S X(IVAL)=IVAL Q:IVAL=4  S Y(IVAL)=IVAL+1"
 S REST=$$GETCMND^XTDEBUG(.RESULTS,CMND)
 ; make sure we have the proper return values to work with
 D CHKEQ^XTMUNIT(RESULTS("CMND"),"F","Bad command returned from GETCMND")
 D CHKEQ^XTMUNIT(RESULTS("ARGS",1),"IVAL=1:1:5","Bad ARGS returned from GETCMND")
 D CHKEQ^XTMUNIT(REST,"S X(IVAL)=IVAL Q:IVAL=4  S Y(IVAL)=IVAL+1","Bad rest of line from GETCMND")
 S @XTDEBLOC@("EXITTYPE")="STEP"
 Q
 ;
FORCMD ;
 N CMND,I,REST,ZZUTXTDI,ZZUTXTDJ,ZZUTXTDG,XTDEBTYP,RESULTS,XTDEBARG
 N XTDEBLOC,ZZUTXTDZ,ZZUTXTDG
 D SETUPFOR
 S XTDEBLOC=$$GETGLOB^XTDEBUG()
 S ZZUTXTDG=$NA(@XTDEBLOC@("VALUES"))
 S @XTDEBLOC@("LASTLVL")=1
 M @XTDEBLOC@("LVL",1,"XTDEBARG")=RESULTS S @XTDEBLOC@("LVL",1,"CMND")=REST
 S @XTDEBLOC@("EXITTYPE")="STEP"
 D STRTFOR^XTDEBUG ;(.RESULTS,REST)
 F ZZUTXTDI=1:1:4 D
 . D NEXT^XTDEBUG(.RESULTS,"STEP") ; SET NEXT I VALUE
 . D CHKEQ^XTMUNIT($G(@ZZUTXTDG@("IVAL")),ZZUTXTDI,"FORCMND first part didn't return expected I value")
 . D NEXT^XTDEBUG(.RESULTS,"STEP") ; execute code
 . S ZZUTXTDZ=$NA(@ZZUTXTDG@("X",ZZUTXTDI))
 . D CHKEQ^XTMUNIT($G(@ZZUTXTDZ),ZZUTXTDI,"FORCMND 2nd part bad value")
 . D NEXT^XTDEBUG(.RESULTS,"STEP")
 . Q
 K @XTDEBLOC@("EXITTYPE")
 Q
 ;
FORQUIT ;
 N CMND,I,REST,ZZUTXTDI,ZZUTXTDJ,ZZUTXTDG,XTDEBTYP,RESULTS,IVAL,X
 N XTDEBLOC,ZZUTENT,ZZUTFLVL,ZZUTLLVL,ZZUTLVL,ZZUTXTDZ
 D SETUPFOR
 S REST="Q:IVAL=3  S X(IVAL)=IVAL"
 ; IVAL=1
 S ZZUTXTDG=$NA(@XTDEBLOC@("VALUES"))
 S @XTDEBLOC@("LASTLVL")=1
 M @XTDEBLOC@("LVL",1,"XTDEBARG")=RESULTS S @XTDEBLOC@("LVL",1,"CMND")=REST
 S @XTDEBLOC@("EXITTYPE")="STEP"
 D STRTFOR^XTDEBUG ;(.RESULTS,REST) ; START AND INITIALIZE VARIABLE
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; CONDITIONAL QUIT (FALSE)
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; SET
 S ZZUTLVL=$$GETGLOB^XTDEBUG(),ZZUTFLVL=$G(@ZZUTLVL@("FORLVL")),ZZUTLLVL=$G(@ZZUTLVL@("LASTLVL")),ZZUTENT=$G(@ZZUTLVL@("LVL",+ZZUTLLVL,"ENTRY"))
 D CHKEQ^XTMUNIT(ZZUTFLVL,1,"BAD FOR LEVEL")
 D CHKEQ^XTMUNIT(ZZUTLLVL,3,"BAD LAST LEVEL")
 ;D CHKEQ^XTMUNIT(ZZUTENT,"FORCMND","INCORRECT ENTRY AT LAST LEVEL")
 S ZZUTXTDZ=$NA(@ZZUTXTDG@("X",1))
 D CHKEQ^XTMUNIT($G(@ZZUTXTDZ),"1","Incorrect return for 1")
 D CHKEQ^XTMUNIT($D(@ZZUTXTDZ),1,"X(1) does not have DATA")
 ; IVAL=2
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; INCREMENT VARIABLE
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; CONDITONAL QUIT (FALSE)
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; SET
 S ZZUTXTDZ=$NA(@ZZUTXTDG@("X",2))
 D CHKEQ^XTMUNIT($G(@ZZUTXTDZ),"2","FOUND X(2) HAS DATA")
 D CHKEQ^XTMUNIT($D(@ZZUTXTDZ),1,"FOUND X(2) does not have DATA")
 ; IVAL=3
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; INCREMENT VALUE
 D NEXT^XTDEBUG(.RESULTS,"STEP") ; CONDITIONAL QUIT (TRUE)
 S ZZUTLVL=$$GETGLOB^XTDEBUG(),ZZUTFLVL=@ZZUTLVL@("FORLVL"),ZZUTLLVL=@ZZUTLVL@("LASTLVL"),ZZUTENT=$G(@ZZUTLVL@("LASTLVL",ZZUTLLVL,"ENTRY"))
 S ZZUTXTDZ=$NA(@ZZUTXTDG@("X",3))
 D CHKEQ^XTMUNIT($G(@ZZUTXTDZ),"","FOUND X(3) HAS DATA")
 D CHKEQ^XTMUNIT($D(@ZZUTXTDZ),0,"FOUND X(3) HAS DATA")
 D CHKEQ^XTMUNIT(ZZUTFLVL,1,"BAD FOR LEVEL")
 D CHKEQ^XTMUNIT(ZZUTLLVL,1,"BAD LAST LEVEL")
 D CHKEQ^XTMUNIT(ZZUTENT,"","INCORRECT ENTRY AT LAST LEVEL")
 K @XTDEBLOC@("EXITTYPE")
 Q
 ;
FORLIMIT ;
 N ZZRESULT,ZZUTX,ZZUTY,ZZUTXTDI
 D START^XTDEBUG(.ZZRESULT,"D FORLIMIT^ZZUTXTD1")
 F ZZUTXTDI=1:1:8 D NEXT^XTDEBUG(.ZZRESULT,"STEP")
 D CHKEQ^XTMUNIT(ZZUTX,6,"BAD VALUE FROM FOR LIMITS")
 Q
 ;
FORLIM1 ;
 N ZZRESULT,ZZUTX,ZZUTXTDI,ZZUTXTDJ,ZZUTSTRT,ZZUTINC,ZZUTMAX,XTDEBLGR
 S XTDEBLGR=$ZR
 S ZZUTSTRT=10,ZZUTINC=-1,ZZUTMAX=5
 D START^XTDEBUG(.ZZRESULT,"D FORLIM1^ZZUTXTD1(ZZUTSTRT,ZZUTINC,ZZUTMAX)")
 F ZZUTXTDJ=1:1:10 D NEXT^XTDEBUG(.ZZRESULT,"STEP")
 D CHKEQ^XTMUNIT($G(ZZUTX),45,"BAD RESULT FROM NEGATIVE INCREMENT, ALL VARIABLES")
 Q
FORCOMMA ;
 N ZZRESULT,ZZUTX,ZZUTXTDI,ZZUTXTDJ,ZZUTSTRT,ZZUTINC,ZZUTMAX
 N XTDEBLGR,ZZUTONE,ZZUTTWO,ZZUTTHRE
 S XTDEBLGR=$ZR
 S ZZUTONE=10,ZZUTTWO=-1,ZZUTTHRE=5
 D START^XTDEBUG(.ZZRESULT,"D FORCOMMA^ZZUTXTD1(ZZUTONE,ZZUTTWO,ZZUTTHRE)")
 ;D FILEINIT^XTMLOG("ZZUTXTD1")
 F ZZUTXTDJ=1:1:10 D NEXT^XTDEBUG(.ZZRESULT,"STEP")
 D CHKEQ^XTMUNIT($G(ZZUTX),"10 -1 5","BAD RESULT FROM COMMA SERIES, NUMBERS, ALL VARIABLES")
 ;D ENDLOG^XTMLOG("ZZUTXTD1")
 ;
 S ZZUTONE="A",ZZUTTWO="1:1:3",ZZUTTHRE="C"
 D START^XTDEBUG(.ZZRESULT,"D FORCOMMA^ZZUTXTD1(ZZUTONE,ZZUTTWO,ZZUTTHRE)")
 ;D FILEINIT^XTMLOG("ZZUTXTD1")
 F ZZUTXTDJ=1:1:10 D NEXT^XTDEBUG(.ZZRESULT,"STEP")
 D CHKEQ^XTMUNIT($G(ZZUTX),"A 1:1:3 C","BAD RESULT FROM COMMA SERIES, NUMBERS, ALL VARIABLES")
 ;D ENDLOG^XTMLOG("ZZUTXTD1")
 ;
 D START^XTDEBUG(.ZZRESULT,"D FORCOMA1^ZZUTXTD1")
 ;D FILEINIT^XTMLOG("ZZUTXTD1")
 F ZZUTXTDJ=1:1:20 D NEXT^XTDEBUG(.ZZRESULT,"STEP")
 D CHKEQ^XTMUNIT($G(ZZUTX),"1 2 3 A 5 7 9 15","BAD RESULT FROM COMMA1 SERIES, MIXED RANGES, FIXED")
 ;D ENDLOG^XTMLOG("ZZUTXTD1")
 Q
 ;
XTROU ;
 ;;ZZUTXTD1;
XTENT ;
 ;;FORCOMMA;check comma series, all variable values
 ;;FORLIM1;check negative increment and all variable values
 ;;TESTNEXT;check NEXT functionality
 ;;GETCMND;get next command and info related to it
 ;;GETSTR;get string with specific terminators
 ;;FORCMD;handle a FOR command
 ;;FORQUIT;handle a FOR command with a quit statement
 ;;FORLIMIT;check proper handling of FOR numeric limits
